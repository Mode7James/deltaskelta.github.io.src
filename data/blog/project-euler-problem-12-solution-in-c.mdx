---
title: "Project Euler: Problem 12 Solution in C"
published: true
createdAt: 2016-07-25T13:55:06.000Z
updatedAt: 2019-01-21T16:24:57.831Z
categories:
  - C
  - Programming
  - Project Euler
---

## The Problem States

```
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
```

## My Solution

I commented the code pretty well. It looks a little bit long but it gets the job done.

The process of getting the `length` of the array seems a bit convoluted and I could probably shorten it up, but it
seemed like a bit of a complicated topic in C so I decided to just write a solution myself. What I did was to iterate
through the array and if I hit a 0 value then I would break the loop. If I reached the 499th index I know I have my
answer. The reason I break on a 0 is because the array is initialized with all 0 values and none of my values can be
0 because then they wouldn't be divisors.

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

//my function to return the number of divisors of a certain number
int *divisors (int num)
{
  //Allocating the space of 500 int's for my future list
  int *divisors = malloc(sizeof(int) * 500);
  int index = 0;
  //iterating while under the square root of num (because each divisor should be higher and lower than the square root)
  for ( int i = 1; i < (lround(sqrt(num)) + 1); i++ ) {
    if ( num % i == 0 ){
      //if there is an even division, I add the divisor that is below the square root
      divisors[index] = i;
      index++;
      //I then add the divisor that is above the square root
      divisors[index] = num / i;
      index ++;
    }
  }
  //Returning the list of divisors to deal with in the main function
  return(divisors);
}

int main ()
{
  clock_t start = clock();

  long triangle = 1;
  //cont is short for continue, I will flip it to 0 to stop the loop
  int cont = 1;
  int toAdd = 1;
  while ( cont ) {
    toAdd += 1;
    triangle += toAdd;
    int *divs = divisors(triangle);
    for ( int i = 0; i < 500; i++ ) {
      if ( divs[i] == 0 ) {
        //If it reaches a 0 in the list, it must be shorter than 500 divisors
        free(divs);
        break;
      } else if ( i == 499 ) {
        //If it reaches this point and it is still not 0 then it must be the answer
        printf("\n%lu\n", triangle);
        //Flipping cont to 0 to exit the loop
        cont = 0;
      }
    }
  }
  clock_t end = clock();
    double time_elapsed_in_seconds = (end - start)/(double)CLOCKS_PER_SEC;
    printf("Finished in %f seconds.\n", time_elapsed_in_seconds);
}
```

## The Output

```bash
76576500
Finished in 0.610586 seconds.
```
