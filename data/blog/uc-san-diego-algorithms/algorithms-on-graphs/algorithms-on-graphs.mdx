---
title: Algorithms On Graphs
published: true
createdAt: 2019-03-23T03:05:59.389Z
updatedAt: 2019-04-21T07:27:02.436Z
images:
  - ./adjacency-matrix.png
  - ./edge-list-operations.png
categories:
  - Programming
  - Algorithms
  - Week 1
---

import { M } from '../../../../src/components/math';

- a graph is a collection of vertices joined by edges
- loop is an edge which connects a vertex to itself
- multiple edges can connect the same vertices

## Graph Representation

<props.imgs.Img1 align="center" width="15%" />

- An edge list is just a list of all of the edges in teh graph. <M i="edges = (A, B), (A, C),(A, D)..."/>.
- An adjacency matrix is a matrix that shows if there is an edge connecting two vertices.
- An Adjacency list stores a list of edges for each vertex

<props.imgs.Img2 align="right" width="40%" />

The operations that can be performed on the graph representations are listed here. `E` is the number of edges `V` is the
number of vertices and `deg` is the number of neighbors that a vertex has. Graph algorithm runtimes have two factors to
take into account with `E` and `V` which means that they are not so easy to compare. If one algorithm
runs in <M i="O(|E|)" /> and another runs in <M i="O(|V|^{3/2})" /> it will depend on the number of
vertices and edges in a particular graph to see which one actually runs faster.

- dense graphs are when the <M i="|E| \approx |V|^2" />. (each vertex has many edges)
- sparse graphs are when <M i="|E| /approx |V|"/>. (each vertex has only a few edges)

## Explore Algorithm

In this algorithm, the `w`'s are the neighbors of `v`. Since we want to iterate over all of the neighbors of v, it would
be best to use an adjacency list because we can easily look up the neighbors. The set of E term means for each neighbor
of V.

```text
Explore(v)
  visited(v) <- true
  for (v, w) of E:
    if not visited(w):
      Explore(w)
```

This will find all of the vertices that are reachable from `v` but it will not find any that are not connected to `v`.

## Depth Frist Search

- each explored vertex is marked as visited
- no vertex is explored after it was visited once
- each vertex is explored exactly once

```text
DFS(G)
  for all v of V:
    mark v unvisited

  for v of V:
    if not visited(v):
      Explore(v)
```

## Connected Components

Connected Components can be seen as an island in a graph. If asked to count the number of connected components, you
should count the number of islands, and it has nothing to do with the counting the connections between vertices. The
runtime of this algorithm is <M i="O(|V| + |E|)" /> because in the worst case it will visit each vertex and
each edge at least once.

```text
Explore(v)
  visited(v) <- true
  CCnum(v) <- cc
  for (v, w) of E:
    if not visited(w):
      Explore(w)
```

```text
DFS(G)
  for all v of V:
    mark v unvisited

  cc <- 1
  for v of V:
    if not visited(v):
      Explore(v)
      cc++
```
